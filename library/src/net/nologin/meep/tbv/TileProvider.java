package net.nologin.meep.tbv;



public interface TileProvider {

    /**
     * @return Return the dimension of the tiles generated by this providers (Tiles are
     * square, so for 128*128, return 128
     */
    public int getTileWidthPixels();

    /**
     * Get the specified tile.  This should be _fast_, otherwise it will slow down the rendering rate.  If it takes
     * time to render tiles, consider using a queueing system. Return null for now (results in an empty square rendered
     * for that particular frame), and let the asynchronous calls to {@link TileProvider#generateNextTile(TileRange)}
     * give you a chance to process the tiles.
     * @param x The x-attribute of the id
     * @param y The y-attribute of the id
     * @return The tile.
     */
    public Tile getTile(int x, int y);

    /**
     * Called from a background thread, this gives the provider a chance to do asynchronous bitmap rendering of any
     * work in the queue without holding up the UI.
     * @param visible Some providers might use this 'turn' to process a tile not currently displayed on
     *                         the screen, and can use this rect to check if the tile currently being processed is
     *                         on screen or not.
     * @return true to indicate processing took place during this call, false if no work needed doing.  This does not
     * guarantee any behaviour by the view, but may be used as a performance hueristic.
     */
    public boolean generateNextTile(TileRange visible);

    /**
     * Allows the provider to specify tile ID boundaries. If specified, scrolling past that tile ID will be prohibited.
     * <br/>
     * Work in progress - Unspecified behaviour occurs if the bounds are too restrictive (ie, less than the
     * initial range displayed on the screen.  This is intended more for limiting excessive scrolling if
     * required, or in the case (for example) where you use the <code>getGridAnchor</code> to anchor y=0 at
     * the top of the screen, and set a top bound of 0 to prevent the user to scroll higher than that.
     *
     * @return <code>null</code> if there are no restrictions on scrolling.  Otherwise, a 4-element Integer
     * array should be specified, specifying the left, top, right, and bottom ID limits respectively.  Each
     * individual element can be left <code>null</code>.  Eg, to enforce that scrolling up can't go beyond
     * y=-5, then specify <code>{null,-5,null,null}</code>.  Invalid arrays will be ignored (same as null).
     */
    public Integer[] getTileIndexBounds();

    /**
     * Tell the provider which tiles are currently visible in the view, giving the provider
     * an opportunity to add new tiles to its rendering queue, or to remove stale tiles
     * from any caches.
     * @param newRange The boundaries of the tile IDs fpsTimeNow on display.
     */
    public void notifyTileIDRangeChange(TileRange newRange);

    /** Called when the user does a zoom pinch
     * @param newZoom a float value from 1.0 to 5.0 (initial is 1.0)
     */
    public void notifyZoomFactorChange(float newZoom);

    /**
     * @return A string for use in the 'debug' mode of the view to show a short summary of the state of
     * the provider, eg "MyProv[cache=100,queue=0]".  Although only called when debug is enabled, try
     * and keep it fast.
     */
    public String getDebugSummary();

    /**
     * @return The screen position where the grid origin will be anchored.  That is,
     * if the view wants to move to a specific tile ID, the view will sroll the grid
     * until the desired tile is at this position.
     */
    public GridAnchor getGridAnchor();



}