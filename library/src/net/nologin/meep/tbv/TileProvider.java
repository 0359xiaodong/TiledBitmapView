package net.nologin.meep.tbv;



public interface TileProvider {

    /**
     * @return Return the dimension of the tiles generated by this providers (Tiles are
     * square, so for 128*128, return 128
     */
    public int getTileWidthPixels();

    /**
     * Get the specified tile.
     * @param x The x-attribute of the id
     * @param y The y-attribute of the id
     * @return The tile.
     */
    public Tile getTile(int x, int y);

    /**
     * Called from a background thread, this gives the provider a chance to render
     * the bitmap contents of next tile in its queue, if any.
     * @param visible Some providers might use this 'turn' to process a tile not currently displayed on
     *                         the screen, and can use this rect to check if the tile currently being processed is
     *                         on screen or not.
     */
    public void generateNextTile(TileRange visible);

    /**
     * Allows the provider to specify tile ID boundaries. If specified, scrolling past that tile ID will be prohibited.
     * <br/>
     * Work in progress - Unspecified behaviour occurs if the bounds are too restrictive (ie, less than the
     * initial range displayed on the screen.  This is intended more for limiting excessive scrolling if
     * required, or in the case (for example) where you use the <code>getGridAnchor</code> to anchor y=0 at
     * the top of the screen, and set a top bound of 0 to prevent the user to scroll higher than that.
     *
     * @return <code>null</code> if there are no restrictions on scrolling.  Otherwise, a 4-element Integer
     * array should be specified, specifying the left, top, right, and bottom ID limits respectively.  Each
     * individual element can be left <code>null</code>.  Eg, to enforce that scrolling up can't go beyond
     * y=-5, then specify <code>{null,-5,null,null}</code>.  Invalid arrays will be ignored (same as null).
     */
    public Integer[] getTileIndexBounds();

    /**
     * Tell the provider which tiles are currently visible in the view, giving the provider
     * an opportunity to add new tiles to its rendering queue, or to remove stale tiles
     * from any caches.
     * @param newRange The boundaries of the tile IDs now on display.
     */
    public void notifyTileIDRangeChange(TileRange newRange);

    public void notifyZoomFactorChangeTEMP(float newZoom);

    public String getDebugSummary();

    /**
     * @return The screen position where the grid origin will be anchored.  That is,
     * if the view wants to move to a specific tile ID, the view will sroll the grid
     * until the desired tile is at this position.
     */
    public GridAnchor getGridAnchor();



}